//===-- llvm/Transforms/IPO/SafeDispatchReturnRange.h --------*- C++ -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file contains a ModulePass for the SafeDispatch backward edge protection.
// It is used to analyse all call sites and generate all the information
// about them that is needed by the backend to insert the return range checks.
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_SAFEDISPATCHRETURNRANGE_H
#define LLVM_SAFEDISPATCHRETURNRANGE_H

#include "llvm/ADT/StringSet.h"
#include "llvm/Transforms/IPO/SafeDispatchCHA.h"
#include "llvm/Transforms/IPO/SafeDispatchLogStream.h"

namespace llvm {

struct SDReturnRange : public ModulePass {
public:
  static char ID; // Pass identification, replacement for typeid
  static const std::string CONSTRUCTION_VTABLE_DEMANGLE_PREFIX;
  static const std::string VTABLE_DEMANGLE_PREFIX;

  SDReturnRange() : ModulePass(ID), CallSiteDebugLocs(), CallSiteDebugLocsStatic(),
                    ClassHierarchies(), CalledFunctions() {
    sdLog::stream() << "initializing SDReturnRange pass\n";
    initializeSDReturnRangePass(*PassRegistry::getPassRegistry());

    pseudoDebugLoc = 0;
  }

  virtual ~SDReturnRange() {
    sdLog::stream() << "deleting SDReturnRange pass\n";
  }

  bool runOnModule(Module &M) override;

  void getAnalysisUsage(AnalysisUsage &AU) const override {
    AU.addRequired<SDBuildCHA>(); //  depends on CHA pass
    AU.setPreservesAll();
  }

  const StringSet<> *getStaticFunctions()  {
    return &CalledFunctions;
  }

private:
  /// class hierarchy information
  SDBuildCHA *CHA;

  /// information about the callSites that are being found by this pass.
  std::vector<std::string> CallSiteDebugLocs;

  /// information about the callSites that are being found by this pass.
  std::vector<std::string> CallSiteDebugLocsStatic;

  /// information about the subclass hierarchies for classes that are being called.
  std::map<std::string, std::set<std::string>> ClassHierarchies;

  /// information about static calls.
  StringSet<> CalledFunctions;

  unsigned pseudoDebugLoc;

  /// Find all callSites that have associated metadata generated by the frontend.
  void locateCallSites(Module &M);

  void locateStaticCallSites(Module &M);

  /// Extract the callSite information from @param CheckedVptrCall and add the CallSite to CallSiteDebugLocs.
  void addCallSite(const CallInst *CheckedVptrCall, CallInst *CallSite, Module &M);

  void addStaticCallSite(CallInst *CallSite, Module &M);

  /// Write the subclass hierarchy of @param RootClassName to ClassHierarchies if not previously done so.
  void emitSubclassHierarchyIfNeeded(StringRef RootClassName);

  /// Helper for 'emitSubclassHierarchyIfNeeded':
  /// Create a subclass hierarchy for @param Root and store it to @param Output.
  void createSubclassHierarchy(const SDBuildCHA::vtbl_t &Root, std::set<std::string> &Output);

  /// Store all callSite information (later retrieved by the backend).
  void storeCallSites(Module &M);

  /// Store all ClassHierarchies (later retrieved by the backend).
  void storeClassHierarchy(Module &M);

  /// Demangle a mangled vtable string and extract the demangled className
  std::string demangleVtableToClassName(StringRef VTableName);
};

}

#endif //LLVM_SAFEDISPATCHRETURNRANGE_H
