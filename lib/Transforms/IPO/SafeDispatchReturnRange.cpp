//===-- SafeDispatchReturnRange.cpp - SafeDispatch ReturnRange code ---------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file implements the SDReturnRange class.
//
//===----------------------------------------------------------------------===//

#include "llvm/Transforms/IPO/SafeDispatchReturnRange.h"

#include "llvm/IR/DebugInfo.h"
#include "llvm/Transforms/IPO/SafeDispatchTools.h"

#include <fstream>
#include <sstream>

using namespace llvm;

//TODO MATT: format properly / code duplication
static StringRef sd_getClassNameFromMD(llvm::MDNode *MDNode, unsigned operandNo = 0) {
  llvm::MDTuple *mdTuple = cast<llvm::MDTuple>(MDNode);
  assert(mdTuple->getNumOperands() > operandNo + 1);

  llvm::MDNode *nameMdNode = cast<llvm::MDNode>(mdTuple->getOperand(operandNo).get());
  llvm::MDString *mdStr = cast<llvm::MDString>(nameMdNode->getOperand(0));

  StringRef strRef = mdStr->getString();
  assert(sd_isVtableName_ref(strRef));
  return strRef;
}

static StringRef sd_getFunctionNameFromMD(llvm::MDNode *MDNode, unsigned operandNo = 0) {
  assert(MDNode->getNumOperands() > operandNo);

  llvm::MDString *mdStr = cast<llvm::MDString>(MDNode->getOperand(operandNo));

  StringRef strRef = mdStr->getString();
  return strRef;
}

static std::stringstream writeDebugLocToStream(const DebugLoc* Loc) {
  assert(Loc);

  auto *Scope = cast<MDScope>(Loc->getScope());
  std::stringstream Stream;
  Stream << Scope->getFilename().str() + ":" << Loc->getLine() << ":" << Loc->getCol();
  return Stream;
}

static bool isBlackListed(const Function &F) {
  return (F.getName().startswith("llvm.") || F.getName().startswith("__")  || F.getName() == "_Znwm");
}

static uint8_t encodeType(Type* T) {
  switch (T->getTypeID()) {
    case Type::TypeID::VoidTyID:
      return 0;

    case Type::TypeID::IntegerTyID:
      auto Bits = cast<IntegerType>(T)->getBitWidth();
      if (Bits <= 1) {
        return 1;
      }
      if (Bits <= 8) {
        return 2;
      }
      if (Bits <= 16) {
        return 3;
      }
      if (Bits <= 32) {
        return 4;
      }
      return 5;

    case Type::TypeID::HalfTyID:
      return 6;
    case Type::TypeID::FloatTyID:
      return 7;
    case Type::TypeID::DoubleTyID:
      return 8;
    case Type::TypeID::X86_FP80TyID:
    case Type::TypeID::FP128TyID:
    case Type::TypeID::PPC_FP128TyID:
      return 9;
    case Type::TypeID::PointerTyID:
      return 10;
    case Type::TypeID::StructTyID:
      return 11;
    case Type::TypeID::ArrayTyID:
      return 12;
    default:
      return 14;
  }
  llvm_unreachable("Unknown TypeID?!");
}

static uint32_t encodeFunction(FunctionType* FuncTy) {
  if (FuncTy->getNumParams() > 5) {
    return 0x7FFFF;
  }
  uint32_t Result = encodeType(FuncTy->getReturnType());
  for (auto *Param : FuncTy->params()) {
    Result = encodeType(Param) + Result * 16;
  }

  return Result + 0x70000;
}

bool SDReturnRange::runOnModule(Module &M) {
  sdLog::blankLine();
  sdLog::stream() << "P7a. Started running the SDReturnRange pass ..." << sdLog::newLine << "\n";

  CHA = &getAnalysis<SDBuildCHA>();

  // Build the virtual ID ranges.
  CHA->buildFunctionInfo();

  // Process Callsites and annotate them for the backend pass.
  processVirtualCallSites(M);
  processStaticCallSites(M);

  // Store the data generated by this pass.
  storeCallSites(M);

  sdLog::stream() << sdLog::newLine << "P7a. Finished running the SDReturnRange pass ..." << "\n";
  sdLog::blankLine();
  return false;
}

void SDReturnRange::processVirtualCallSites(Module &M) {
  Function *IntrinsicFunction = M.getFunction(Intrinsic::getName(Intrinsic::sd_get_checked_vptr));

  if (IntrinsicFunction == nullptr) {
    sdLog::warn() << "Intrinsic not found.\n";
    return;
  }

  sdLog::stream() << "\n";
  sdLog::stream() << "Processing virtual CallSites...\n";
  int count = 0;
  for (const Use &U : IntrinsicFunction->uses()) {

    // get the intrinsic call instruction
    CallInst *IntrinsicCall = dyn_cast<CallInst>(U.getUser());
    assert(IntrinsicCall && "Intrinsic was not wrapped in a CallInst?");

    // Find the CallSite that is associated with the intrinsic call.
    User *User = *(IntrinsicCall->users().begin());
    for (int i = 0; i < 3; ++i) {
      // User was not found, this should not happen...
      if (User == nullptr)
        break;
      errs() << User << "\n";

      for (auto *NextUser : User->users()) {
        User = NextUser;
        break;
      }
    }

    CallSite CallSite(User);
    if (CallSite.getInstruction()) {
      // valid CallSite
      addVirtualCallSite(IntrinsicCall, CallSite, M);
    } else {
      sdLog::log() << "\n";
      sdLog::warn() << "CallSite for intrinsic was not found.\n";
      IntrinsicCall->getParent()->dump();
    }
    ++count;
    sdLog::log() << "\n";
  }
  sdLog::stream() << "Found virtual CallSites: " << count << "\n";

}

void SDReturnRange::processStaticCallSites(Module &M) {
  int totalDirect = 0;
  int totalIndirect = 0;
  int countDirect = 0;
  int countIndirect = 0;

  sdLog::stream() << "\n";
  sdLog::stream() << "Processing static CallSites...\n";
  for (auto &F : M) {
    for(auto &MBB : F) {
      for (auto &I : MBB) {
        CallSite Call(&I);
        // Try to use I as a CallInst or a InvokeInst
        if (Call.getInstruction()) {
          if (Function *Callee = Call.getCalledFunction()) {
            if (!isBlackListed(*Callee)){
              addStaticCallSite(Call, M);
              ++countDirect;
            }
          } else if (CallSite(Call).isIndirectCall() && VirtualCallSites.find(Call) == VirtualCallSites.end()) {
            addStaticCallSite(Call, M);
            ++countIndirect;
          }
        }
      }
    }
    sdLog::stream() << F.getName() << " (direct: " << countDirect << ", indirect:"<< countIndirect << ")\n";
    totalDirect += countDirect;
    totalIndirect += countIndirect;
    countDirect = countIndirect = 0;
  }

  sdLog::stream() << "\n";
  sdLog::stream() << "Found direct static CallSites: " << totalDirect << "\n";
  sdLog::stream() << "Found indirect CallSites: " << totalIndirect << "\n";
  sdLog::stream() << "\n";
}

void SDReturnRange::addStaticCallSite(CallSite CallSite, Module &M) {
  assert(CallSite.getInstruction() && "Not a CallInst or InvokeInst!");

  std::string FunctionName;
  if (CallSite.getCalledFunction()) {
    // Direct Call
    FunctionName = CallSite.getCalledFunction()->getName().str();
    CalledFunctions.insert(FunctionName);
  } else if (CallSite.isTailCall()) {
    // Tail Call
    FunctionName = "__TAIL__";
  } else {
    // Indirect Call
    FunctionName = "__INDIRECT__";
    Type *Ty = CallSite.getCalledValue()->getType();
    if (auto *PointerTy = dyn_cast<PointerType>(Ty)) {
      if (auto *FuncTy = dyn_cast<FunctionType>(PointerTy->getElementType())) {
        uint64_t FunctionTypeID = encodeFunction(FuncTy);
        FunctionName = "__INDIRECT__" + std::to_string(FunctionTypeID);
      }
    }
  }

  // write DebugLoc to map
  const DebugLoc* Loc = getOrCreateDebugLoc(CallSite, M);
  std::stringstream Stream = writeDebugLocToStream(Loc);
  std::string DebugLocString = Stream.str();
  Stream <<  "," << FunctionName;
  CallSiteDebugLocsStatic.push_back(Stream.str());

  sdLog::log() << "Static CallSite " << CallSite->getParent()->getParent()->getName()
               << "(@" << DebugLocString
               << ") for Callee " << FunctionName << "\n";
}

void SDReturnRange::addVirtualCallSite(const CallInst *IntrinsicCall, CallSite CallSite, Module &M) {
  // Extract Metadata from Intrinsic.
  MetadataAsValue *Arg2 = dyn_cast<MetadataAsValue>(IntrinsicCall->getArgOperand(1));
  assert(Arg2);
  MDNode *ClassNameNode = dyn_cast<MDNode>(Arg2->getMetadata());
  assert(ClassNameNode);

  MetadataAsValue *Arg3 = dyn_cast<MetadataAsValue>(IntrinsicCall->getArgOperand(2));
  assert(Arg3);
  MDNode *PreciseNameNode = dyn_cast<MDNode>(Arg2->getMetadata());
  assert(PreciseNameNode);

  MetadataAsValue *Arg4 = dyn_cast<MetadataAsValue>(IntrinsicCall->getArgOperand(3));
  assert(Arg4);
  MDNode *FunctionNameNode = dyn_cast<MDNode>(Arg4->getMetadata());
  assert(FunctionNameNode);

  const StringRef ClassName = sd_getClassNameFromMD(ClassNameNode);
  const StringRef PreciseName = sd_getClassNameFromMD(PreciseNameNode);
  const StringRef FunctionName = sd_getFunctionNameFromMD(FunctionNameNode);

  // Find the correct ID range for this FunctionName.
  std::vector<SDBuildCHA::range_t> ranges = CHA->getFunctionRange(FunctionName, ClassName);
  if (ranges.empty()) {
    sdLog::errs() << "Call for " << FunctionName << " (" << ClassName << "," << PreciseName << ") has no range!?\n";
    return;
  }

  // Write DebugLoc to map
  const DebugLoc* Loc = getOrCreateDebugLoc(CallSite, M);
  std::stringstream Stream = writeDebugLocToStream(Loc);
  std::string DebugLocString = Stream.str();
  // Add metadata and range info to Stream.
  Stream << "," << ClassName.str() << "," << PreciseName.str() << "," << FunctionName.str()
         << "," << ranges[0].first << "," << ranges[0].second;
  CallSiteDebugLocsVirtual.push_back(Stream.str());

  // Add to VirtualCallsites
  VirtualCallSites.insert(CallSite);

  sdLog::log() << "Virtual CallSite (@" << DebugLocString
               << " for class " << ClassName << "(" << PreciseName << ")::" << FunctionName << "\n";
}

void SDReturnRange::storeCallSites(Module &M) {
  sdLog::stream() << "Store all CallSites for Module: " << M.getName() << "\n";

  // Find new backup number
  int number = 0;
  auto outName = "./SD_CallSitesVirtual-backup" + std::to_string(number);
  std::ifstream infile(outName);
  while (infile.good()) {
    number++;
    outName = "./SD_CallSitesVirtual-backup" + std::to_string(number);
    infile = std::ifstream(outName);
  }

  // Virtual
  {
    std::ofstream Outfile("./SD_CallSitesVirtual");
    std::ostream_iterator<std::string> OutIterator(Outfile, "\n");
    std::copy(CallSiteDebugLocsVirtual.begin(), CallSiteDebugLocsVirtual.end(), OutIterator);
    sdLog::stream() << "Stored virtual CallSites: " << CallSiteDebugLocsVirtual.size() << "\n";
    Outfile.close();

    // Write backup
    std::ifstream src("./SD_CallSites-backup", std::ios::binary);
    std::ofstream dst(outName, std::ios::binary);
    dst << src.rdbuf();
  }

  // Static
  {
    std::ofstream Outfile("./SD_CallSitesStatic");
    std::ostream_iterator<std::string> OutIterator(Outfile, "\n");
    std::copy(CallSiteDebugLocsStatic.begin(), CallSiteDebugLocsStatic.end(), OutIterator);
    sdLog::stream() << "Stored static CallSites: " << CallSiteDebugLocsStatic.size() << "\n";
    Outfile.close();

    // Write backup
    outName = "./SD_CallSitesStatic-backup" + std::to_string(number);
    std::ifstream src2("./SD_CallSitesStatic", std::ios::binary);
    std::ofstream dst2(outName, std::ios::binary);
    dst2 << src2.rdbuf();
  }
}

const DebugLoc* SDReturnRange::getOrCreateDebugLoc(CallSite CallSite, Module &M) {
  const DebugLoc &Loc = CallSite.getInstruction()->getDebugLoc();
  if (!Loc) {
    // Minor hack: We generate our own DebugLoc using a dummy MDSubprogram.
    // pseudoDebugLoc is the unique ID for this CallSite.
    llvm::LLVMContext &C = M.getContext();
    auto DummyProgram = MDSubprogram::getDistinct(C, nullptr, "", "", nullptr, 0,
                                                  nullptr, false, false, 0, nullptr, 0, 0, 0,
                                                  0);
    MDLocation *Location = MDLocation::getDistinct(C,
                                                   uint32_t(pseudoDebugLoc / 65536),
                                                   uint32_t(pseudoDebugLoc % 65536), DummyProgram);
    ++pseudoDebugLoc;
    DebugLoc newLoc(Location);
    CallSite.getInstruction()->setDebugLoc(Location);
  }
  return &Loc;
}

char SDReturnRange::ID = 0;

INITIALIZE_PASS(SDReturnRange, "sdRetRange", "Build return ranges", false, false)

ModulePass *llvm::createSDReturnRangePass() {
  return new SDReturnRange();
}